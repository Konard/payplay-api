<?php
/**
 * DefaultApi
 * PHP version 8.1
 *
 * @category Class
 * @package  PayPlayClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PayPlay API
 *
 * PayPlay API documentation generated from markdown files
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PayPlayClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use PayPlayClient\ApiException;
use PayPlayClient\Configuration;
use PayPlayClient\FormDataProcessor;
use PayPlayClient\HeaderSelector;
use PayPlayClient\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  PayPlayClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'completeCryptoOrder' => [
            'application/json',
        ],
        'confirmConvertWithdrawal' => [
            'application/json',
        ],
        'createAcquiring' => [
            'application/json',
        ],
        'createBalances' => [
            'application/json',
        ],
        'createConvertWithdrawal' => [
            'application/json',
        ],
        'createCryptoOrder' => [
            'application/json',
        ],
        'createCryptoTopups' => [
            'application/json',
        ],
        'createInstantConvertWithdrawal' => [
            'application/json',
        ],
        'createMassPayout' => [
            'application/json',
        ],
        'createRefund' => [
            'application/json',
        ],
        'createWithdrawal' => [
            'application/json',
        ],
        'getAcquiringOrderID' => [
            'application/json',
        ],
        'getBalanceBalanceID' => [
            'application/json',
        ],
        'getBalanceBalances' => [
            'application/json',
        ],
        'getCryptoOrderOrderID' => [
            'application/json',
        ],
        'getCryptoOrderSlug' => [
            'application/json',
        ],
        'getCurrenciesCryptoOrderTargetCurrencies' => [
            'application/json',
        ],
        'getCurrenciesCryptoTopupTargetCurrencies' => [
            'application/json',
        ],
        'getCurrenciesCurrencies' => [
            'application/json',
        ],
        'getCurrenciesCurrencies1' => [
            'application/json',
        ],
        'getExchangeRatesCurrencyTicker' => [
            'application/json',
        ],
        'getOrderOrderId' => [
            'application/json',
        ],
        'getOrderSlug' => [
            'application/json',
        ],
        'getOrderStatuses' => [
            'application/json',
        ],
        'getRateRates' => [
            'application/json',
        ],
        'getTransactionTransactionID' => [
            'application/json',
        ],
        'getTransactionTransactions' => [
            'application/json',
        ],
        'getWithdrawalFees' => [
            'application/json',
        ],
        'refreshConvertWithdrawal' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation completeCryptoOrder
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeCryptoOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function completeCryptoOrder($slug, $order_id, string $contentType = self::contentTypes['completeCryptoOrder'][0])
    {
        list($response) = $this->completeCryptoOrderWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation completeCryptoOrderWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeCryptoOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeCryptoOrderWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['completeCryptoOrder'][0])
    {
        $request = $this->completeCryptoOrderRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation completeCryptoOrderAsync
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeCryptoOrderAsync($slug, $order_id, string $contentType = self::contentTypes['completeCryptoOrder'][0])
    {
        return $this->completeCryptoOrderAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeCryptoOrderAsyncWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeCryptoOrderAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['completeCryptoOrder'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->completeCryptoOrderRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeCryptoOrder'
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function completeCryptoOrderRequest($slug, $order_id, string $contentType = self::contentTypes['completeCryptoOrder'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling completeCryptoOrder'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling completeCryptoOrder'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}/{orderID}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation confirmConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies200Response
     */
    public function confirmConvertWithdrawal($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        list($response) = $this->confirmConvertWithdrawalWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation confirmConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function confirmConvertWithdrawalWithHttpInfo($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        $request = $this->confirmConvertWithdrawalRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation confirmConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmConvertWithdrawalAsync($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        return $this->confirmConvertWithdrawalAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmConvertWithdrawalAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies200Response';
        $request = $this->confirmConvertWithdrawalRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmConvertWithdrawal'
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function confirmConvertWithdrawalRequest($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling confirmConvertWithdrawal'
            );
        }


        $resourcePath = '/private-api/convert-withdrawal/{transactionID}/confirm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionID' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAcquiring
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAcquiring'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies1200Response
     */
    public function createAcquiring($slug, string $contentType = self::contentTypes['createAcquiring'][0])
    {
        list($response) = $this->createAcquiringWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createAcquiringWithHttpInfo
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAcquiring'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies1200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAcquiringWithHttpInfo($slug, string $contentType = self::contentTypes['createAcquiring'][0])
    {
        $request = $this->createAcquiringRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createAcquiringAsync
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAcquiring'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAcquiringAsync($slug, string $contentType = self::contentTypes['createAcquiring'][0])
    {
        return $this->createAcquiringAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAcquiringAsyncWithHttpInfo
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAcquiring'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAcquiringAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createAcquiring'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response';
        $request = $this->createAcquiringRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAcquiring'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAcquiring'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAcquiringRequest($slug, string $contentType = self::contentTypes['createAcquiring'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createAcquiring'
            );
        }


        $resourcePath = '/acquiring/{slug}/pay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBalances
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetBalanceBalances200Response
     */
    public function createBalances($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        list($response) = $this->createBalancesWithHttpInfo($balance_id, $contentType);
        return $response;
    }

    /**
     * Operation createBalancesWithHttpInfo
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetBalanceBalances200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBalancesWithHttpInfo($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        $request = $this->createBalancesRequest($balance_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetBalanceBalances200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetBalanceBalances200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetBalanceBalances200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createBalancesAsync
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBalancesAsync($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        return $this->createBalancesAsyncWithHttpInfo($balance_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBalancesAsyncWithHttpInfo
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBalancesAsyncWithHttpInfo($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        $returnType = '\PayPlayClient\Model\GetBalanceBalances200Response';
        $request = $this->createBalancesRequest($balance_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBalances'
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createBalancesRequest($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {

        // verify the required parameter 'balance_id' is set
        if ($balance_id === null || (is_array($balance_id) && count($balance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_id when calling createBalances'
            );
        }


        $resourcePath = '/private-api/balances/{balanceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($balance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'balanceID' . '}',
                ObjectSerializer::toPathValue($balance_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies200Response
     */
    public function createConvertWithdrawal($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        list($response) = $this->createConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);
        return $response;
    }

    /**
     * Operation createConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        $request = $this->createConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConvertWithdrawalAsync($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        return $this->createConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies200Response';
        $request = $this->createConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConvertWithdrawal'
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'target_currency' is set
        if ($target_currency === null || (is_array($target_currency) && count($target_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_currency when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createConvertWithdrawal'
            );
        }




        $resourcePath = '/private-api/convert-withdrawal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_currency,
            'target_currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network,
            'network', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $memo,
            'memo', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCryptoOrder
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function createCryptoOrder($slug, string $contentType = self::contentTypes['createCryptoOrder'][0])
    {
        list($response) = $this->createCryptoOrderWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createCryptoOrderWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCryptoOrderWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoOrder'][0])
    {
        $request = $this->createCryptoOrderRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCryptoOrderAsync
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoOrderAsync($slug, string $contentType = self::contentTypes['createCryptoOrder'][0])
    {
        return $this->createCryptoOrderAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCryptoOrderAsyncWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoOrderAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoOrder'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->createCryptoOrderRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCryptoOrder'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCryptoOrderRequest($slug, string $contentType = self::contentTypes['createCryptoOrder'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createCryptoOrder'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCryptoTopups
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function createCryptoTopups($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        list($response) = $this->createCryptoTopupsWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createCryptoTopupsWithHttpInfo
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCryptoTopupsWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        $request = $this->createCryptoTopupsRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCryptoTopupsAsync
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoTopupsAsync($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        return $this->createCryptoTopupsAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCryptoTopupsAsyncWithHttpInfo
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoTopupsAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->createCryptoTopupsRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCryptoTopups'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCryptoTopupsRequest($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createCryptoTopups'
            );
        }


        $resourcePath = '/private-api/crypto-topups/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createInstantConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies200Response
     */
    public function createInstantConvertWithdrawal($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createInstantConvertWithdrawal'][0])
    {
        list($response) = $this->createInstantConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);
        return $response;
    }

    /**
     * Operation createInstantConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createInstantConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createInstantConvertWithdrawal'][0])
    {
        $request = $this->createInstantConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createInstantConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInstantConvertWithdrawalAsync($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createInstantConvertWithdrawal'][0])
    {
        return $this->createInstantConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createInstantConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createInstantConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createInstantConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies200Response';
        $request = $this->createInstantConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createInstantConvertWithdrawal'
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createInstantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createInstantConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createInstantConvertWithdrawal'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling createInstantConvertWithdrawal'
            );
        }

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling createInstantConvertWithdrawal'
            );
        }

        // verify the required parameter 'target_currency' is set
        if ($target_currency === null || (is_array($target_currency) && count($target_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_currency when calling createInstantConvertWithdrawal'
            );
        }

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling createInstantConvertWithdrawal'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createInstantConvertWithdrawal'
            );
        }




        $resourcePath = '/private-api/convert-withdrawal/instant';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_currency,
            'target_currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network,
            'network', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $memo,
            'memo', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMassPayout
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateWithdrawal200Response
     */
    public function createMassPayout(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        list($response) = $this->createMassPayoutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation createMassPayoutWithHttpInfo
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateWithdrawal200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMassPayoutWithHttpInfo(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        $request = $this->createMassPayoutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateWithdrawal200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMassPayoutAsync
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMassPayoutAsync(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        return $this->createMassPayoutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMassPayoutAsyncWithHttpInfo
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMassPayoutAsyncWithHttpInfo(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateWithdrawal200Response';
        $request = $this->createMassPayoutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMassPayout'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMassPayoutRequest(string $contentType = self::contentTypes['createMassPayout'][0])
    {


        $resourcePath = '/mass-payouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRefund
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateRefund200Response
     */
    public function createRefund($order_id, string $contentType = self::contentTypes['createRefund'][0])
    {
        list($response) = $this->createRefundWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation createRefundWithHttpInfo
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateRefund200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRefundWithHttpInfo($order_id, string $contentType = self::contentTypes['createRefund'][0])
    {
        $request = $this->createRefundRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateRefund200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateRefund200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateRefund200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRefundAsync
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRefundAsync($order_id, string $contentType = self::contentTypes['createRefund'][0])
    {
        return $this->createRefundAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRefundAsyncWithHttpInfo
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRefundAsyncWithHttpInfo($order_id, string $contentType = self::contentTypes['createRefund'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateRefund200Response';
        $request = $this->createRefundRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRefund'
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefund'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRefundRequest($order_id, string $contentType = self::contentTypes['createRefund'][0])
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling createRefund'
            );
        }


        $resourcePath = '/private-api/refunds/orders/{orderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWithdrawal
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateWithdrawal200Response
     */
    public function createWithdrawal($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        list($response) = $this->createWithdrawalWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createWithdrawalWithHttpInfo
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateWithdrawal200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithdrawalWithHttpInfo($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        $request = $this->createWithdrawalRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateWithdrawal200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createWithdrawalAsync
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithdrawalAsync($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        return $this->createWithdrawalAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithdrawalAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateWithdrawal200Response';
        $request = $this->createWithdrawalRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWithdrawal'
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWithdrawalRequest($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createWithdrawal'
            );
        }


        $resourcePath = '/private-api/{slug}/withdrawal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAcquiringOrderID
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrderID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies1200Response
     */
    public function getAcquiringOrderID($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrderID'][0])
    {
        list($response) = $this->getAcquiringOrderIDWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getAcquiringOrderIDWithHttpInfo
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrderID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies1200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAcquiringOrderIDWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrderID'][0])
    {
        $request = $this->getAcquiringOrderIDRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAcquiringOrderIDAsync
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrderID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAcquiringOrderIDAsync($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrderID'][0])
    {
        return $this->getAcquiringOrderIDAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAcquiringOrderIDAsyncWithHttpInfo
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrderID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAcquiringOrderIDAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrderID'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response';
        $request = $this->getAcquiringOrderIDRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAcquiringOrderID'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrderID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAcquiringOrderIDRequest($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrderID'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getAcquiringOrderID'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getAcquiringOrderID'
            );
        }


        $resourcePath = '/acquiring/{slug}/order/{orderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalanceBalanceID
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalanceID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetBalanceBalances200Response
     */
    public function getBalanceBalanceID($balance_id, string $contentType = self::contentTypes['getBalanceBalanceID'][0])
    {
        list($response) = $this->getBalanceBalanceIDWithHttpInfo($balance_id, $contentType);
        return $response;
    }

    /**
     * Operation getBalanceBalanceIDWithHttpInfo
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalanceID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetBalanceBalances200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceBalanceIDWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalanceBalanceID'][0])
    {
        $request = $this->getBalanceBalanceIDRequest($balance_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetBalanceBalances200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetBalanceBalances200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetBalanceBalances200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBalanceBalanceIDAsync
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalanceID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceBalanceIDAsync($balance_id, string $contentType = self::contentTypes['getBalanceBalanceID'][0])
    {
        return $this->getBalanceBalanceIDAsyncWithHttpInfo($balance_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceBalanceIDAsyncWithHttpInfo
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalanceID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceBalanceIDAsyncWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalanceBalanceID'][0])
    {
        $returnType = '\PayPlayClient\Model\GetBalanceBalances200Response';
        $request = $this->getBalanceBalanceIDRequest($balance_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalanceBalanceID'
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalanceID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBalanceBalanceIDRequest($balance_id, string $contentType = self::contentTypes['getBalanceBalanceID'][0])
    {

        // verify the required parameter 'balance_id' is set
        if ($balance_id === null || (is_array($balance_id) && count($balance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_id when calling getBalanceBalanceID'
            );
        }


        $resourcePath = '/private-api/balances/{balanceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($balance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'balanceID' . '}',
                ObjectSerializer::toPathValue($balance_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalanceBalances
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetBalanceBalances200Response
     */
    public function getBalanceBalances($balance_id, string $contentType = self::contentTypes['getBalanceBalances'][0])
    {
        list($response) = $this->getBalanceBalancesWithHttpInfo($balance_id, $contentType);
        return $response;
    }

    /**
     * Operation getBalanceBalancesWithHttpInfo
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetBalanceBalances200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceBalancesWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalanceBalances'][0])
    {
        $request = $this->getBalanceBalancesRequest($balance_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetBalanceBalances200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetBalanceBalances200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetBalanceBalances200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBalanceBalancesAsync
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceBalancesAsync($balance_id, string $contentType = self::contentTypes['getBalanceBalances'][0])
    {
        return $this->getBalanceBalancesAsyncWithHttpInfo($balance_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceBalancesAsyncWithHttpInfo
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceBalancesAsyncWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalanceBalances'][0])
    {
        $returnType = '\PayPlayClient\Model\GetBalanceBalances200Response';
        $request = $this->getBalanceBalancesRequest($balance_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalanceBalances'
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalanceBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBalanceBalancesRequest($balance_id, string $contentType = self::contentTypes['getBalanceBalances'][0])
    {

        // verify the required parameter 'balance_id' is set
        if ($balance_id === null || (is_array($balance_id) && count($balance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_id when calling getBalanceBalances'
            );
        }


        $resourcePath = '/private-api/balances/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $balance_id,
            'balanceID', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCryptoOrderOrderID
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderOrderID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function getCryptoOrderOrderID($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrderOrderID'][0])
    {
        list($response) = $this->getCryptoOrderOrderIDWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getCryptoOrderOrderIDWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderOrderID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCryptoOrderOrderIDWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrderOrderID'][0])
    {
        $request = $this->getCryptoOrderOrderIDRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCryptoOrderOrderIDAsync
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderOrderID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrderOrderIDAsync($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrderOrderID'][0])
    {
        return $this->getCryptoOrderOrderIDAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCryptoOrderOrderIDAsyncWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderOrderID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrderOrderIDAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrderOrderID'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->getCryptoOrderOrderIDRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCryptoOrderOrderID'
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderOrderID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCryptoOrderOrderIDRequest($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrderOrderID'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCryptoOrderOrderID'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getCryptoOrderOrderID'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}/{orderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCryptoOrderSlug
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderSlug'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function getCryptoOrderSlug($slug, string $contentType = self::contentTypes['getCryptoOrderSlug'][0])
    {
        list($response) = $this->getCryptoOrderSlugWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation getCryptoOrderSlugWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderSlug'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCryptoOrderSlugWithHttpInfo($slug, string $contentType = self::contentTypes['getCryptoOrderSlug'][0])
    {
        $request = $this->getCryptoOrderSlugRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCryptoOrderSlugAsync
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderSlug'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrderSlugAsync($slug, string $contentType = self::contentTypes['getCryptoOrderSlug'][0])
    {
        return $this->getCryptoOrderSlugAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCryptoOrderSlugAsyncWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderSlug'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrderSlugAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['getCryptoOrderSlug'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->getCryptoOrderSlugRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCryptoOrderSlug'
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrderSlug'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCryptoOrderSlugRequest($slug, string $contentType = self::contentTypes['getCryptoOrderSlug'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCryptoOrderSlug'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrenciesCryptoOrderTargetCurrencies
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function getCurrenciesCryptoOrderTargetCurrencies($slug, $order_id, string $contentType = self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'][0])
    {
        list($response) = $this->getCurrenciesCryptoOrderTargetCurrenciesWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getCurrenciesCryptoOrderTargetCurrenciesWithHttpInfo
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrenciesCryptoOrderTargetCurrenciesWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'][0])
    {
        $request = $this->getCurrenciesCryptoOrderTargetCurrenciesRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrenciesCryptoOrderTargetCurrenciesAsync
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCryptoOrderTargetCurrenciesAsync($slug, $order_id, string $contentType = self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'][0])
    {
        return $this->getCurrenciesCryptoOrderTargetCurrenciesAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrenciesCryptoOrderTargetCurrenciesAsyncWithHttpInfo
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCryptoOrderTargetCurrenciesAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->getCurrenciesCryptoOrderTargetCurrenciesRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrenciesCryptoOrderTargetCurrencies'
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrenciesCryptoOrderTargetCurrenciesRequest($slug, $order_id, string $contentType = self::contentTypes['getCurrenciesCryptoOrderTargetCurrencies'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCurrenciesCryptoOrderTargetCurrencies'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getCurrenciesCryptoOrderTargetCurrencies'
            );
        }


        $resourcePath = '/currencies/crypto-order-target-currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_id,
            'orderID', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrenciesCryptoTopupTargetCurrencies
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrderSlug200Response
     */
    public function getCurrenciesCryptoTopupTargetCurrencies(string $contentType = self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'][0])
    {
        list($response) = $this->getCurrenciesCryptoTopupTargetCurrenciesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getCurrenciesCryptoTopupTargetCurrenciesWithHttpInfo
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrderSlug200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrenciesCryptoTopupTargetCurrenciesWithHttpInfo(string $contentType = self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'][0])
    {
        $request = $this->getCurrenciesCryptoTopupTargetCurrenciesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrderSlug200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrenciesCryptoTopupTargetCurrenciesAsync
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCryptoTopupTargetCurrenciesAsync(string $contentType = self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'][0])
    {
        return $this->getCurrenciesCryptoTopupTargetCurrenciesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrenciesCryptoTopupTargetCurrenciesAsyncWithHttpInfo
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCryptoTopupTargetCurrenciesAsyncWithHttpInfo(string $contentType = self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrderSlug200Response';
        $request = $this->getCurrenciesCryptoTopupTargetCurrenciesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrenciesCryptoTopupTargetCurrencies'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrenciesCryptoTopupTargetCurrenciesRequest(string $contentType = self::contentTypes['getCurrenciesCryptoTopupTargetCurrencies'][0])
    {


        $resourcePath = '/private-api/currencies/crypto-topup-target-currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrenciesCurrencies
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies200Response
     */
    public function getCurrenciesCurrencies($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getCurrenciesCurrencies'][0])
    {
        list($response) = $this->getCurrenciesCurrenciesWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);
        return $response;
    }

    /**
     * Operation getCurrenciesCurrenciesWithHttpInfo
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrenciesCurrenciesWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getCurrenciesCurrencies'][0])
    {
        $request = $this->getCurrenciesCurrenciesRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrenciesCurrenciesAsync
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCurrenciesAsync($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getCurrenciesCurrencies'][0])
    {
        return $this->getCurrenciesCurrenciesAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrenciesCurrenciesAsyncWithHttpInfo
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCurrenciesAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getCurrenciesCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies200Response';
        $request = $this->getCurrenciesCurrenciesRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrenciesCurrencies'
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrenciesCurrenciesRequest($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getCurrenciesCurrencies'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getCurrenciesCurrencies'
            );
        }

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling getCurrenciesCurrencies'
            );
        }

        // verify the required parameter 'target_currency' is set
        if ($target_currency === null || (is_array($target_currency) && count($target_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_currency when calling getCurrenciesCurrencies'
            );
        }

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getCurrenciesCurrencies'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling getCurrenciesCurrencies'
            );
        }




        $resourcePath = '/private-api/convert-withdrawal/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_currency,
            'target_currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network,
            'network', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $memo,
            'memo', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrenciesCurrencies1
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies1'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies1200Response
     */
    public function getCurrenciesCurrencies1($slug, string $contentType = self::contentTypes['getCurrenciesCurrencies1'][0])
    {
        list($response) = $this->getCurrenciesCurrencies1WithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation getCurrenciesCurrencies1WithHttpInfo
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies1'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies1200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrenciesCurrencies1WithHttpInfo($slug, string $contentType = self::contentTypes['getCurrenciesCurrencies1'][0])
    {
        $request = $this->getCurrenciesCurrencies1Request($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrenciesCurrencies1Async
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCurrencies1Async($slug, string $contentType = self::contentTypes['getCurrenciesCurrencies1'][0])
    {
        return $this->getCurrenciesCurrencies1AsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrenciesCurrencies1AsyncWithHttpInfo
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrenciesCurrencies1AsyncWithHttpInfo($slug, string $contentType = self::contentTypes['getCurrenciesCurrencies1'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies1200Response';
        $request = $this->getCurrenciesCurrencies1Request($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrenciesCurrencies1'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrenciesCurrencies1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrenciesCurrencies1Request($slug, string $contentType = self::contentTypes['getCurrenciesCurrencies1'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCurrenciesCurrencies1'
            );
        }


        $resourcePath = '/acquiring/{slug}/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExchangeRatesCurrencyTicker
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRatesCurrencyTicker'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getExchangeRatesCurrencyTicker($currency_ticker, string $contentType = self::contentTypes['getExchangeRatesCurrencyTicker'][0])
    {
        list($response) = $this->getExchangeRatesCurrencyTickerWithHttpInfo($currency_ticker, $contentType);
        return $response;
    }

    /**
     * Operation getExchangeRatesCurrencyTickerWithHttpInfo
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRatesCurrencyTicker'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExchangeRatesCurrencyTickerWithHttpInfo($currency_ticker, string $contentType = self::contentTypes['getExchangeRatesCurrencyTicker'][0])
    {
        $request = $this->getExchangeRatesCurrencyTickerRequest($currency_ticker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getExchangeRatesCurrencyTickerAsync
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRatesCurrencyTicker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExchangeRatesCurrencyTickerAsync($currency_ticker, string $contentType = self::contentTypes['getExchangeRatesCurrencyTicker'][0])
    {
        return $this->getExchangeRatesCurrencyTickerAsyncWithHttpInfo($currency_ticker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExchangeRatesCurrencyTickerAsyncWithHttpInfo
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRatesCurrencyTicker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExchangeRatesCurrencyTickerAsyncWithHttpInfo($currency_ticker, string $contentType = self::contentTypes['getExchangeRatesCurrencyTicker'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getExchangeRatesCurrencyTickerRequest($currency_ticker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExchangeRatesCurrencyTicker'
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRatesCurrencyTicker'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExchangeRatesCurrencyTickerRequest($currency_ticker, string $contentType = self::contentTypes['getExchangeRatesCurrencyTicker'][0])
    {

        // verify the required parameter 'currency_ticker' is set
        if ($currency_ticker === null || (is_array($currency_ticker) && count($currency_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_ticker when calling getExchangeRatesCurrencyTicker'
            );
        }


        $resourcePath = '/private-api/exchange-rates/{currencyTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyTicker' . '}',
                ObjectSerializer::toPathValue($currency_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderOrderId
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderOrderId'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getOrderOrderId($slug, $order_id, string $contentType = self::contentTypes['getOrderOrderId'][0])
    {
        list($response) = $this->getOrderOrderIdWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrderOrderIdWithHttpInfo
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderOrderId'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderOrderIdWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getOrderOrderId'][0])
    {
        $request = $this->getOrderOrderIdRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOrderOrderIdAsync
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderOrderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderOrderIdAsync($slug, $order_id, string $contentType = self::contentTypes['getOrderOrderId'][0])
    {
        return $this->getOrderOrderIdAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderOrderIdAsyncWithHttpInfo
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderOrderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderOrderIdAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getOrderOrderId'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getOrderOrderIdRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderOrderId'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderOrderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderOrderIdRequest($slug, $order_id, string $contentType = self::contentTypes['getOrderOrderId'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getOrderOrderId'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getOrderOrderId'
            );
        }


        $resourcePath = '/private-api/orders/{slug}/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderSlug
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderSlug'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getOrderSlug($slug, string $contentType = self::contentTypes['getOrderSlug'][0])
    {
        list($response) = $this->getOrderSlugWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation getOrderSlugWithHttpInfo
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderSlug'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderSlugWithHttpInfo($slug, string $contentType = self::contentTypes['getOrderSlug'][0])
    {
        $request = $this->getOrderSlugRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOrderSlugAsync
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderSlug'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderSlugAsync($slug, string $contentType = self::contentTypes['getOrderSlug'][0])
    {
        return $this->getOrderSlugAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderSlugAsyncWithHttpInfo
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderSlug'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderSlugAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['getOrderSlug'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getOrderSlugRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderSlug'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderSlug'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderSlugRequest($slug, string $contentType = self::contentTypes['getOrderSlug'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getOrderSlug'
            );
        }


        $resourcePath = '/private-api/orders/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderStatuses
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getOrderStatuses($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        list($response) = $this->getOrderStatusesWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrderStatusesWithHttpInfo
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderStatusesWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        $request = $this->getOrderStatusesRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOrderStatusesAsync
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusesAsync($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        return $this->getOrderStatusesAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderStatusesAsyncWithHttpInfo
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusesAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getOrderStatusesRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderStatuses'
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderStatusesRequest($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling getOrderStatuses'
            );
        }


        $resourcePath = '/private-api/order-statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transaction_id,
            'transactionID', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRateRates
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRateRates'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getRateRates(string $contentType = self::contentTypes['getRateRates'][0])
    {
        list($response) = $this->getRateRatesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRateRatesWithHttpInfo
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRateRates'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRateRatesWithHttpInfo(string $contentType = self::contentTypes['getRateRates'][0])
    {
        $request = $this->getRateRatesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRateRatesAsync
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRateRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRateRatesAsync(string $contentType = self::contentTypes['getRateRates'][0])
    {
        return $this->getRateRatesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRateRatesAsyncWithHttpInfo
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRateRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRateRatesAsyncWithHttpInfo(string $contentType = self::contentTypes['getRateRates'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getRateRatesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRateRates'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRateRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRateRatesRequest(string $contentType = self::contentTypes['getRateRates'][0])
    {


        $resourcePath = '/rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionTransactionID
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactionID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getTransactionTransactionID($transaction_id, string $contentType = self::contentTypes['getTransactionTransactionID'][0])
    {
        list($response) = $this->getTransactionTransactionIDWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation getTransactionTransactionIDWithHttpInfo
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactionID'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionTransactionIDWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getTransactionTransactionID'][0])
    {
        $request = $this->getTransactionTransactionIDRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTransactionTransactionIDAsync
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactionID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionTransactionIDAsync($transaction_id, string $contentType = self::contentTypes['getTransactionTransactionID'][0])
    {
        return $this->getTransactionTransactionIDAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionTransactionIDAsyncWithHttpInfo
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactionID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionTransactionIDAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getTransactionTransactionID'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getTransactionTransactionIDRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionTransactionID'
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactionID'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTransactionTransactionIDRequest($transaction_id, string $contentType = self::contentTypes['getTransactionTransactionID'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling getTransactionTransactionID'
            );
        }


        $resourcePath = '/private-api/transactions/{transactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionID' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactionTransactions
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactions'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrderOrderId200Response
     */
    public function getTransactionTransactions(string $contentType = self::contentTypes['getTransactionTransactions'][0])
    {
        list($response) = $this->getTransactionTransactionsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTransactionTransactionsWithHttpInfo
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactions'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrderOrderId200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionTransactionsWithHttpInfo(string $contentType = self::contentTypes['getTransactionTransactions'][0])
    {
        $request = $this->getTransactionTransactionsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrderOrderId200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrderOrderId200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTransactionTransactionsAsync
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionTransactionsAsync(string $contentType = self::contentTypes['getTransactionTransactions'][0])
    {
        return $this->getTransactionTransactionsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionTransactionsAsyncWithHttpInfo
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionTransactionsAsyncWithHttpInfo(string $contentType = self::contentTypes['getTransactionTransactions'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrderOrderId200Response';
        $request = $this->getTransactionTransactionsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactionTransactions'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactionTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTransactionTransactionsRequest(string $contentType = self::contentTypes['getTransactionTransactions'][0])
    {


        $resourcePath = '/private-api/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWithdrawalFees
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateWithdrawal200Response
     */
    public function getWithdrawalFees(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        list($response) = $this->getWithdrawalFeesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getWithdrawalFeesWithHttpInfo
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateWithdrawal200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithdrawalFeesWithHttpInfo(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        $request = $this->getWithdrawalFeesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateWithdrawal200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getWithdrawalFeesAsync
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalFeesAsync(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        return $this->getWithdrawalFeesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWithdrawalFeesAsyncWithHttpInfo
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalFeesAsyncWithHttpInfo(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateWithdrawal200Response';
        $request = $this->getWithdrawalFeesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWithdrawalFees'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWithdrawalFeesRequest(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {


        $resourcePath = '/private-api/withdrawals/fees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refreshConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCurrenciesCurrencies200Response
     */
    public function refreshConvertWithdrawal($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        list($response) = $this->refreshConvertWithdrawalWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation refreshConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCurrenciesCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function refreshConvertWithdrawalWithHttpInfo($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        $request = $this->refreshConvertWithdrawalRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCurrenciesCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation refreshConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshConvertWithdrawalAsync($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        return $this->refreshConvertWithdrawalAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refreshConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshConvertWithdrawalAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCurrenciesCurrencies200Response';
        $request = $this->refreshConvertWithdrawalRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refreshConvertWithdrawal'
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refreshConvertWithdrawalRequest($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling refreshConvertWithdrawal'
            );
        }


        $resourcePath = '/private-api/convert-withdrawal/{transactionID}/refresh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionID' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
