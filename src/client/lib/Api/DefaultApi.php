<?php
/**
 * DefaultApi
 * PHP version 8.1
 *
 * @category Class
 * @package  PayPlayClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PayPlay API
 *
 * PayPlay API documentation generated from markdown files
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.13.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PayPlayClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use PayPlayClient\ApiException;
use PayPlayClient\Configuration;
use PayPlayClient\FormDataProcessor;
use PayPlayClient\HeaderSelector;
use PayPlayClient\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  PayPlayClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'confirmConvertWithdrawal' => [
            'application/json',
        ],
        'createBalances' => [
            'application/json',
        ],
        'createConvertWithdrawal' => [
            'application/json',
        ],
        'createCryptoOrders' => [
            'application/json',
        ],
        'createCryptoOrdersComplete' => [
            'application/json',
        ],
        'createCryptoTopups' => [
            'application/json',
        ],
        'createMassPayout' => [
            'application/json',
        ],
        'createRefundsOrders' => [
            'application/json',
        ],
        'createWithdrawal' => [
            'application/json',
        ],
        'getAcquiringCurrencies' => [
            'application/json',
        ],
        'getAcquiringOrder' => [
            'application/json',
        ],
        'getBalance' => [
            'application/json',
        ],
        'getBalances' => [
            'application/json',
        ],
        'getConvertWithdrawalCurrencies' => [
            'application/json',
        ],
        'getCryptoOrder' => [
            'application/json',
        ],
        'getCryptoOrders' => [
            'application/json',
        ],
        'getCurrencyCryptoOrderTargetCurrencies' => [
            'application/json',
        ],
        'getCurrencyCryptoTopupTargetCurrencies' => [
            'application/json',
        ],
        'getExchangeRate' => [
            'application/json',
        ],
        'getOrder' => [
            'application/json',
        ],
        'getOrderStatuses' => [
            'application/json',
        ],
        'getOrders' => [
            'application/json',
        ],
        'getRates' => [
            'application/json',
        ],
        'getTransaction' => [
            'application/json',
        ],
        'getTransactions' => [
            'application/json',
        ],
        'getWithdrawalFees' => [
            'application/json',
        ],
        'instantConvertWithdrawal' => [
            'application/json',
        ],
        'payAcquiring' => [
            'application/json',
        ],
        'refreshConvertWithdrawal' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation confirmConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response
     */
    public function confirmConvertWithdrawal($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        list($response) = $this->confirmConvertWithdrawalWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation confirmConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function confirmConvertWithdrawalWithHttpInfo($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        $request = $this->confirmConvertWithdrawalRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation confirmConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmConvertWithdrawalAsync($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        return $this->confirmConvertWithdrawalAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation confirmConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/confirm
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function confirmConvertWithdrawalAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response';
        $request = $this->confirmConvertWithdrawalRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'confirmConvertWithdrawal'
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['confirmConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function confirmConvertWithdrawalRequest($transaction_id, string $contentType = self::contentTypes['confirmConvertWithdrawal'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling confirmConvertWithdrawal'
            );
        }


        $resourcePath = '/private-api/convert-withdrawal/{transactionID}/confirm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionID' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createBalances
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetBalances200Response
     */
    public function createBalances($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        list($response) = $this->createBalancesWithHttpInfo($balance_id, $contentType);
        return $response;
    }

    /**
     * Operation createBalancesWithHttpInfo
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetBalances200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBalancesWithHttpInfo($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        $request = $this->createBalancesRequest($balance_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetBalances200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetBalances200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetBalances200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createBalancesAsync
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBalancesAsync($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        return $this->createBalancesAsyncWithHttpInfo($balance_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBalancesAsyncWithHttpInfo
     *
     * POST /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBalancesAsyncWithHttpInfo($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {
        $returnType = '\PayPlayClient\Model\GetBalances200Response';
        $request = $this->createBalancesRequest($balance_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBalances'
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createBalancesRequest($balance_id, string $contentType = self::contentTypes['createBalances'][0])
    {

        // verify the required parameter 'balance_id' is set
        if ($balance_id === null || (is_array($balance_id) && count($balance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_id when calling createBalances'
            );
        }


        $resourcePath = '/private-api/balances/{balanceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($balance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'balanceID' . '}',
                ObjectSerializer::toPathValue($balance_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response
     */
    public function createConvertWithdrawal($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        list($response) = $this->createConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);
        return $response;
    }

    /**
     * Operation createConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        $request = $this->createConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConvertWithdrawalAsync($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        return $this->createConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response';
        $request = $this->createConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConvertWithdrawal'
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['createConvertWithdrawal'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'target_currency' is set
        if ($target_currency === null || (is_array($target_currency) && count($target_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_currency when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling createConvertWithdrawal'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createConvertWithdrawal'
            );
        }




        $resourcePath = '/private-api/convert-withdrawal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_currency,
            'target_currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network,
            'network', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $memo,
            'memo', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCryptoOrders
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function createCryptoOrders($slug, string $contentType = self::contentTypes['createCryptoOrders'][0])
    {
        list($response) = $this->createCryptoOrdersWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createCryptoOrdersWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCryptoOrdersWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoOrders'][0])
    {
        $request = $this->createCryptoOrdersRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCryptoOrdersAsync
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoOrdersAsync($slug, string $contentType = self::contentTypes['createCryptoOrders'][0])
    {
        return $this->createCryptoOrdersAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCryptoOrdersAsyncWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoOrdersAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoOrders'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->createCryptoOrdersRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCryptoOrders'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCryptoOrdersRequest($slug, string $contentType = self::contentTypes['createCryptoOrders'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createCryptoOrders'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCryptoOrdersComplete
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrdersComplete'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function createCryptoOrdersComplete($slug, $order_id, string $contentType = self::contentTypes['createCryptoOrdersComplete'][0])
    {
        list($response) = $this->createCryptoOrdersCompleteWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation createCryptoOrdersCompleteWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrdersComplete'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCryptoOrdersCompleteWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['createCryptoOrdersComplete'][0])
    {
        $request = $this->createCryptoOrdersCompleteRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCryptoOrdersCompleteAsync
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrdersComplete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoOrdersCompleteAsync($slug, $order_id, string $contentType = self::contentTypes['createCryptoOrdersComplete'][0])
    {
        return $this->createCryptoOrdersCompleteAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCryptoOrdersCompleteAsyncWithHttpInfo
     *
     * POST /private-api/crypto-orders/{slug}/{orderID}/complete
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrdersComplete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoOrdersCompleteAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['createCryptoOrdersComplete'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->createCryptoOrdersCompleteRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCryptoOrdersComplete'
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoOrdersComplete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCryptoOrdersCompleteRequest($slug, $order_id, string $contentType = self::contentTypes['createCryptoOrdersComplete'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createCryptoOrdersComplete'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling createCryptoOrdersComplete'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}/{orderID}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCryptoTopups
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function createCryptoTopups($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        list($response) = $this->createCryptoTopupsWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createCryptoTopupsWithHttpInfo
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCryptoTopupsWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        $request = $this->createCryptoTopupsRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createCryptoTopupsAsync
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoTopupsAsync($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        return $this->createCryptoTopupsAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCryptoTopupsAsyncWithHttpInfo
     *
     * POST /private-api/crypto-topups/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCryptoTopupsAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->createCryptoTopupsRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCryptoTopups'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCryptoTopups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCryptoTopupsRequest($slug, string $contentType = self::contentTypes['createCryptoTopups'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createCryptoTopups'
            );
        }


        $resourcePath = '/private-api/crypto-topups/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMassPayout
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateWithdrawal200Response
     */
    public function createMassPayout(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        list($response) = $this->createMassPayoutWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation createMassPayoutWithHttpInfo
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateWithdrawal200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMassPayoutWithHttpInfo(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        $request = $this->createMassPayoutRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateWithdrawal200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMassPayoutAsync
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMassPayoutAsync(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        return $this->createMassPayoutAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMassPayoutAsyncWithHttpInfo
     *
     * POST /mass-payouts
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMassPayoutAsyncWithHttpInfo(string $contentType = self::contentTypes['createMassPayout'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateWithdrawal200Response';
        $request = $this->createMassPayoutRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMassPayout'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMassPayout'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMassPayoutRequest(string $contentType = self::contentTypes['createMassPayout'][0])
    {


        $resourcePath = '/mass-payouts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRefundsOrders
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefundsOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateRefundsOrders200Response
     */
    public function createRefundsOrders($order_id, string $contentType = self::contentTypes['createRefundsOrders'][0])
    {
        list($response) = $this->createRefundsOrdersWithHttpInfo($order_id, $contentType);
        return $response;
    }

    /**
     * Operation createRefundsOrdersWithHttpInfo
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefundsOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateRefundsOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRefundsOrdersWithHttpInfo($order_id, string $contentType = self::contentTypes['createRefundsOrders'][0])
    {
        $request = $this->createRefundsOrdersRequest($order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateRefundsOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateRefundsOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateRefundsOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRefundsOrdersAsync
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefundsOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRefundsOrdersAsync($order_id, string $contentType = self::contentTypes['createRefundsOrders'][0])
    {
        return $this->createRefundsOrdersAsyncWithHttpInfo($order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRefundsOrdersAsyncWithHttpInfo
     *
     * POST /private-api/refunds/orders/{orderID}
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefundsOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRefundsOrdersAsyncWithHttpInfo($order_id, string $contentType = self::contentTypes['createRefundsOrders'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateRefundsOrders200Response';
        $request = $this->createRefundsOrdersRequest($order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRefundsOrders'
     *
     * @param  string $order_id PayPlay order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRefundsOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRefundsOrdersRequest($order_id, string $contentType = self::contentTypes['createRefundsOrders'][0])
    {

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling createRefundsOrders'
            );
        }


        $resourcePath = '/private-api/refunds/orders/{orderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWithdrawal
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateWithdrawal200Response
     */
    public function createWithdrawal($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        list($response) = $this->createWithdrawalWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation createWithdrawalWithHttpInfo
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateWithdrawal200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithdrawalWithHttpInfo($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        $request = $this->createWithdrawalRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateWithdrawal200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createWithdrawalAsync
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithdrawalAsync($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        return $this->createWithdrawalAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/{slug}/withdrawal
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithdrawalAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateWithdrawal200Response';
        $request = $this->createWithdrawalRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWithdrawal'
     *
     * @param  string $slug unique instance name defined for the company. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWithdrawalRequest($slug, string $contentType = self::contentTypes['createWithdrawal'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling createWithdrawal'
            );
        }


        $resourcePath = '/private-api/{slug}/withdrawal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAcquiringCurrencies
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetAcquiringCurrencies200Response
     */
    public function getAcquiringCurrencies($slug, string $contentType = self::contentTypes['getAcquiringCurrencies'][0])
    {
        list($response) = $this->getAcquiringCurrenciesWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation getAcquiringCurrenciesWithHttpInfo
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetAcquiringCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAcquiringCurrenciesWithHttpInfo($slug, string $contentType = self::contentTypes['getAcquiringCurrencies'][0])
    {
        $request = $this->getAcquiringCurrenciesRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAcquiringCurrenciesAsync
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAcquiringCurrenciesAsync($slug, string $contentType = self::contentTypes['getAcquiringCurrencies'][0])
    {
        return $this->getAcquiringCurrenciesAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAcquiringCurrenciesAsyncWithHttpInfo
     *
     * GET /acquiring/{slug}/currencies
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAcquiringCurrenciesAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['getAcquiringCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetAcquiringCurrencies200Response';
        $request = $this->getAcquiringCurrenciesRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAcquiringCurrencies'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAcquiringCurrenciesRequest($slug, string $contentType = self::contentTypes['getAcquiringCurrencies'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getAcquiringCurrencies'
            );
        }


        $resourcePath = '/acquiring/{slug}/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAcquiringOrder
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetAcquiringCurrencies200Response
     */
    public function getAcquiringOrder($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrder'][0])
    {
        list($response) = $this->getAcquiringOrderWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getAcquiringOrderWithHttpInfo
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetAcquiringCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAcquiringOrderWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrder'][0])
    {
        $request = $this->getAcquiringOrderRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAcquiringOrderAsync
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAcquiringOrderAsync($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrder'][0])
    {
        return $this->getAcquiringOrderAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAcquiringOrderAsyncWithHttpInfo
     *
     * GET /acquiring/{slug}/order/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAcquiringOrderAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrder'][0])
    {
        $returnType = '\PayPlayClient\Model\GetAcquiringCurrencies200Response';
        $request = $this->getAcquiringOrderRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAcquiringOrder'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id PayPlay internal order id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAcquiringOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAcquiringOrderRequest($slug, $order_id, string $contentType = self::contentTypes['getAcquiringOrder'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getAcquiringOrder'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getAcquiringOrder'
            );
        }


        $resourcePath = '/acquiring/{slug}/order/{orderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalance
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalance'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetBalances200Response
     */
    public function getBalance($balance_id, string $contentType = self::contentTypes['getBalance'][0])
    {
        list($response) = $this->getBalanceWithHttpInfo($balance_id, $contentType);
        return $response;
    }

    /**
     * Operation getBalanceWithHttpInfo
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalance'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetBalances200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalanceWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalance'][0])
    {
        $request = $this->getBalanceRequest($balance_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetBalances200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetBalances200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetBalances200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBalanceAsync
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceAsync($balance_id, string $contentType = self::contentTypes['getBalance'][0])
    {
        return $this->getBalanceAsyncWithHttpInfo($balance_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalanceAsyncWithHttpInfo
     *
     * GET /private-api/balances/{balanceID}
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalanceAsyncWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalance'][0])
    {
        $returnType = '\PayPlayClient\Model\GetBalances200Response';
        $request = $this->getBalanceRequest($balance_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalance'
     *
     * @param  string $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBalanceRequest($balance_id, string $contentType = self::contentTypes['getBalance'][0])
    {

        // verify the required parameter 'balance_id' is set
        if ($balance_id === null || (is_array($balance_id) && count($balance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_id when calling getBalance'
            );
        }


        $resourcePath = '/private-api/balances/{balanceID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($balance_id !== null) {
            $resourcePath = str_replace(
                '{' . 'balanceID' . '}',
                ObjectSerializer::toPathValue($balance_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBalances
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetBalances200Response
     */
    public function getBalances($balance_id, string $contentType = self::contentTypes['getBalances'][0])
    {
        list($response) = $this->getBalancesWithHttpInfo($balance_id, $contentType);
        return $response;
    }

    /**
     * Operation getBalancesWithHttpInfo
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalances'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetBalances200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBalancesWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalances'][0])
    {
        $request = $this->getBalancesRequest($balance_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetBalances200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetBalances200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetBalances200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getBalancesAsync
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalancesAsync($balance_id, string $contentType = self::contentTypes['getBalances'][0])
    {
        return $this->getBalancesAsyncWithHttpInfo($balance_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBalancesAsyncWithHttpInfo
     *
     * GET /private-api/balances/
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBalancesAsyncWithHttpInfo($balance_id, string $contentType = self::contentTypes['getBalances'][0])
    {
        $returnType = '\PayPlayClient\Model\GetBalances200Response';
        $request = $this->getBalancesRequest($balance_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBalances'
     *
     * @param  mixed $balance_id balance id in specified balance currency (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getBalances'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBalancesRequest($balance_id, string $contentType = self::contentTypes['getBalances'][0])
    {

        // verify the required parameter 'balance_id' is set
        if ($balance_id === null || (is_array($balance_id) && count($balance_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $balance_id when calling getBalances'
            );
        }


        $resourcePath = '/private-api/balances/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $balance_id,
            'balanceID', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConvertWithdrawalCurrencies
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConvertWithdrawalCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response
     */
    public function getConvertWithdrawalCurrencies($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getConvertWithdrawalCurrencies'][0])
    {
        list($response) = $this->getConvertWithdrawalCurrenciesWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);
        return $response;
    }

    /**
     * Operation getConvertWithdrawalCurrenciesWithHttpInfo
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConvertWithdrawalCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConvertWithdrawalCurrenciesWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getConvertWithdrawalCurrencies'][0])
    {
        $request = $this->getConvertWithdrawalCurrenciesRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getConvertWithdrawalCurrenciesAsync
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConvertWithdrawalCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConvertWithdrawalCurrenciesAsync($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getConvertWithdrawalCurrencies'][0])
    {
        return $this->getConvertWithdrawalCurrenciesAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConvertWithdrawalCurrenciesAsyncWithHttpInfo
     *
     * GET /private-api/convert-withdrawal/currencies
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConvertWithdrawalCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConvertWithdrawalCurrenciesAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getConvertWithdrawalCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response';
        $request = $this->getConvertWithdrawalCurrenciesRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConvertWithdrawalCurrencies'
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConvertWithdrawalCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConvertWithdrawalCurrenciesRequest($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['getConvertWithdrawalCurrencies'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling getConvertWithdrawalCurrencies'
            );
        }

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling getConvertWithdrawalCurrencies'
            );
        }

        // verify the required parameter 'target_currency' is set
        if ($target_currency === null || (is_array($target_currency) && count($target_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_currency when calling getConvertWithdrawalCurrencies'
            );
        }

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling getConvertWithdrawalCurrencies'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling getConvertWithdrawalCurrencies'
            );
        }




        $resourcePath = '/private-api/convert-withdrawal/currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_currency,
            'target_currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network,
            'network', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $memo,
            'memo', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCryptoOrder
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function getCryptoOrder($slug, string $contentType = self::contentTypes['getCryptoOrder'][0])
    {
        list($response) = $this->getCryptoOrderWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation getCryptoOrderWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCryptoOrderWithHttpInfo($slug, string $contentType = self::contentTypes['getCryptoOrder'][0])
    {
        $request = $this->getCryptoOrderRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCryptoOrderAsync
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrderAsync($slug, string $contentType = self::contentTypes['getCryptoOrder'][0])
    {
        return $this->getCryptoOrderAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCryptoOrderAsyncWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrderAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['getCryptoOrder'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->getCryptoOrderRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCryptoOrder'
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCryptoOrderRequest($slug, string $contentType = self::contentTypes['getCryptoOrder'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCryptoOrder'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCryptoOrders
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function getCryptoOrders($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrders'][0])
    {
        list($response) = $this->getCryptoOrdersWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getCryptoOrdersWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCryptoOrdersWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrders'][0])
    {
        $request = $this->getCryptoOrdersRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCryptoOrdersAsync
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrdersAsync($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrders'][0])
    {
        return $this->getCryptoOrdersAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCryptoOrdersAsyncWithHttpInfo
     *
     * GET /private-api/crypto-orders/{slug}/{orderID}
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCryptoOrdersAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrders'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->getCryptoOrdersRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCryptoOrders'
     *
     * @param  string $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCryptoOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCryptoOrdersRequest($slug, $order_id, string $contentType = self::contentTypes['getCryptoOrders'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCryptoOrders'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getCryptoOrders'
            );
        }


        $resourcePath = '/private-api/crypto-orders/{slug}/{orderID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderID' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrencyCryptoOrderTargetCurrencies
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function getCurrencyCryptoOrderTargetCurrencies($slug, $order_id, string $contentType = self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'][0])
    {
        list($response) = $this->getCurrencyCryptoOrderTargetCurrenciesWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getCurrencyCryptoOrderTargetCurrenciesWithHttpInfo
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrencyCryptoOrderTargetCurrenciesWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'][0])
    {
        $request = $this->getCurrencyCryptoOrderTargetCurrenciesRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrencyCryptoOrderTargetCurrenciesAsync
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyCryptoOrderTargetCurrenciesAsync($slug, $order_id, string $contentType = self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'][0])
    {
        return $this->getCurrencyCryptoOrderTargetCurrenciesAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrencyCryptoOrderTargetCurrenciesAsyncWithHttpInfo
     *
     * GET /currencies/crypto-order-target-currencies
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyCryptoOrderTargetCurrenciesAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->getCurrencyCryptoOrderTargetCurrenciesRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencyCryptoOrderTargetCurrencies'
     *
     * @param  mixed $slug unique instance name defined for payment page. Can be found on each payment page settings page in CRM. (required)
     * @param  mixed $order_id PayPlay internal order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrencyCryptoOrderTargetCurrenciesRequest($slug, $order_id, string $contentType = self::contentTypes['getCurrencyCryptoOrderTargetCurrencies'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getCurrencyCryptoOrderTargetCurrencies'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getCurrencyCryptoOrderTargetCurrencies'
            );
        }


        $resourcePath = '/currencies/crypto-order-target-currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $slug,
            'slug', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_id,
            'orderID', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCurrencyCryptoTopupTargetCurrencies
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetCryptoOrder200Response
     */
    public function getCurrencyCryptoTopupTargetCurrencies(string $contentType = self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'][0])
    {
        list($response) = $this->getCurrencyCryptoTopupTargetCurrenciesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getCurrencyCryptoTopupTargetCurrenciesWithHttpInfo
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetCryptoOrder200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCurrencyCryptoTopupTargetCurrenciesWithHttpInfo(string $contentType = self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'][0])
    {
        $request = $this->getCurrencyCryptoTopupTargetCurrenciesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetCryptoOrder200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetCryptoOrder200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCurrencyCryptoTopupTargetCurrenciesAsync
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyCryptoTopupTargetCurrenciesAsync(string $contentType = self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'][0])
    {
        return $this->getCurrencyCryptoTopupTargetCurrenciesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCurrencyCryptoTopupTargetCurrenciesAsyncWithHttpInfo
     *
     * GET /private-api/currencies/crypto-topup-target-currencies
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCurrencyCryptoTopupTargetCurrenciesAsyncWithHttpInfo(string $contentType = self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'][0])
    {
        $returnType = '\PayPlayClient\Model\GetCryptoOrder200Response';
        $request = $this->getCurrencyCryptoTopupTargetCurrenciesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCurrencyCryptoTopupTargetCurrencies'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCurrencyCryptoTopupTargetCurrenciesRequest(string $contentType = self::contentTypes['getCurrencyCryptoTopupTargetCurrencies'][0])
    {


        $resourcePath = '/private-api/currencies/crypto-topup-target-currencies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getExchangeRate
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRate'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getExchangeRate($currency_ticker, string $contentType = self::contentTypes['getExchangeRate'][0])
    {
        list($response) = $this->getExchangeRateWithHttpInfo($currency_ticker, $contentType);
        return $response;
    }

    /**
     * Operation getExchangeRateWithHttpInfo
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRate'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getExchangeRateWithHttpInfo($currency_ticker, string $contentType = self::contentTypes['getExchangeRate'][0])
    {
        $request = $this->getExchangeRateRequest($currency_ticker, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getExchangeRateAsync
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExchangeRateAsync($currency_ticker, string $contentType = self::contentTypes['getExchangeRate'][0])
    {
        return $this->getExchangeRateAsyncWithHttpInfo($currency_ticker, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getExchangeRateAsyncWithHttpInfo
     *
     * GET /private-api/exchange-rates/{currencyTicker}
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getExchangeRateAsyncWithHttpInfo($currency_ticker, string $contentType = self::contentTypes['getExchangeRate'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getExchangeRateRequest($currency_ticker, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getExchangeRate'
     *
     * @param  string $currency_ticker The currencyTicker parameter in the URL path (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getExchangeRate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getExchangeRateRequest($currency_ticker, string $contentType = self::contentTypes['getExchangeRate'][0])
    {

        // verify the required parameter 'currency_ticker' is set
        if ($currency_ticker === null || (is_array($currency_ticker) && count($currency_ticker) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency_ticker when calling getExchangeRate'
            );
        }


        $resourcePath = '/private-api/exchange-rates/{currencyTicker}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($currency_ticker !== null) {
            $resourcePath = str_replace(
                '{' . 'currencyTicker' . '}',
                ObjectSerializer::toPathValue($currency_ticker),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrder
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getOrder($slug, string $contentType = self::contentTypes['getOrder'][0])
    {
        list($response) = $this->getOrderWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation getOrderWithHttpInfo
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrder'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderWithHttpInfo($slug, string $contentType = self::contentTypes['getOrder'][0])
    {
        $request = $this->getOrderRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOrderAsync
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderAsync($slug, string $contentType = self::contentTypes['getOrder'][0])
    {
        return $this->getOrderAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderAsyncWithHttpInfo
     *
     * GET /private-api/orders/{slug}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['getOrder'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getOrderRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrder'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderRequest($slug, string $contentType = self::contentTypes['getOrder'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getOrder'
            );
        }


        $resourcePath = '/private-api/orders/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrderStatuses
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getOrderStatuses($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        list($response) = $this->getOrderStatusesWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrderStatusesWithHttpInfo
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrderStatusesWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        $request = $this->getOrderStatusesRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOrderStatusesAsync
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusesAsync($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        return $this->getOrderStatusesAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrderStatusesAsyncWithHttpInfo
     *
     * GET /private-api/order-statuses
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrderStatusesAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getOrderStatusesRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrderStatuses'
     *
     * @param  mixed $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrderStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrderStatusesRequest($transaction_id, string $contentType = self::contentTypes['getOrderStatuses'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling getOrderStatuses'
            );
        }


        $resourcePath = '/private-api/order-statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $transaction_id,
            'transactionID', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrders
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getOrders($slug, $order_id, string $contentType = self::contentTypes['getOrders'][0])
    {
        list($response) = $this->getOrdersWithHttpInfo($slug, $order_id, $contentType);
        return $response;
    }

    /**
     * Operation getOrdersWithHttpInfo
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrdersWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getOrders'][0])
    {
        $request = $this->getOrdersRequest($slug, $order_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOrdersAsync
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrdersAsync($slug, $order_id, string $contentType = self::contentTypes['getOrders'][0])
    {
        return $this->getOrdersAsyncWithHttpInfo($slug, $order_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrdersAsyncWithHttpInfo
     *
     * GET /private-api/orders/{slug}/{orderId}
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrdersAsyncWithHttpInfo($slug, $order_id, string $contentType = self::contentTypes['getOrders'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getOrdersRequest($slug, $order_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrders'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $order_id unique identifier of order (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOrders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrdersRequest($slug, $order_id, string $contentType = self::contentTypes['getOrders'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling getOrders'
            );
        }

        // verify the required parameter 'order_id' is set
        if ($order_id === null || (is_array($order_id) && count($order_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_id when calling getOrders'
            );
        }


        $resourcePath = '/private-api/orders/{slug}/{orderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($order_id !== null) {
            $resourcePath = str_replace(
                '{' . 'orderId' . '}',
                ObjectSerializer::toPathValue($order_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRates
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRates'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getRates(string $contentType = self::contentTypes['getRates'][0])
    {
        list($response) = $this->getRatesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRatesWithHttpInfo
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRates'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRatesWithHttpInfo(string $contentType = self::contentTypes['getRates'][0])
    {
        $request = $this->getRatesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRatesAsync
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatesAsync(string $contentType = self::contentTypes['getRates'][0])
    {
        return $this->getRatesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRatesAsyncWithHttpInfo
     *
     * GET /rates
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRatesAsyncWithHttpInfo(string $contentType = self::contentTypes['getRates'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getRatesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRates'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRatesRequest(string $contentType = self::contentTypes['getRates'][0])
    {


        $resourcePath = '/rates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransaction
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransaction'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getTransaction($transaction_id, string $contentType = self::contentTypes['getTransaction'][0])
    {
        list($response) = $this->getTransactionWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation getTransactionWithHttpInfo
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransaction'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getTransaction'][0])
    {
        $request = $this->getTransactionRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTransactionAsync
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionAsync($transaction_id, string $contentType = self::contentTypes['getTransaction'][0])
    {
        return $this->getTransactionAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionAsyncWithHttpInfo
     *
     * GET /private-api/transactions/{transactionID}
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['getTransaction'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getTransactionRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransaction'
     *
     * @param  string $transaction_id PayPlay internal transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTransactionRequest($transaction_id, string $contentType = self::contentTypes['getTransaction'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling getTransaction'
            );
        }


        $resourcePath = '/private-api/transactions/{transactionID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionID' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTransactions
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactions'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetOrders200Response
     */
    public function getTransactions(string $contentType = self::contentTypes['getTransactions'][0])
    {
        list($response) = $this->getTransactionsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTransactionsWithHttpInfo
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactions'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetOrders200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTransactionsWithHttpInfo(string $contentType = self::contentTypes['getTransactions'][0])
    {
        $request = $this->getTransactionsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetOrders200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetOrders200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetOrders200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTransactionsAsync
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionsAsync(string $contentType = self::contentTypes['getTransactions'][0])
    {
        return $this->getTransactionsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTransactionsAsyncWithHttpInfo
     *
     * GET /private-api/transactions
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTransactionsAsyncWithHttpInfo(string $contentType = self::contentTypes['getTransactions'][0])
    {
        $returnType = '\PayPlayClient\Model\GetOrders200Response';
        $request = $this->getTransactionsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTransactions'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTransactionsRequest(string $contentType = self::contentTypes['getTransactions'][0])
    {


        $resourcePath = '/private-api/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWithdrawalFees
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\CreateWithdrawal200Response
     */
    public function getWithdrawalFees(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        list($response) = $this->getWithdrawalFeesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getWithdrawalFeesWithHttpInfo
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\CreateWithdrawal200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithdrawalFeesWithHttpInfo(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        $request = $this->getWithdrawalFeesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\CreateWithdrawal200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\CreateWithdrawal200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getWithdrawalFeesAsync
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalFeesAsync(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        return $this->getWithdrawalFeesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWithdrawalFeesAsyncWithHttpInfo
     *
     * GET /private-api/withdrawals/fees
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWithdrawalFeesAsyncWithHttpInfo(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {
        $returnType = '\PayPlayClient\Model\CreateWithdrawal200Response';
        $request = $this->getWithdrawalFeesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWithdrawalFees'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWithdrawalFees'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWithdrawalFeesRequest(string $contentType = self::contentTypes['getWithdrawalFees'][0])
    {


        $resourcePath = '/private-api/withdrawals/fees';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation instantConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response
     */
    public function instantConvertWithdrawal($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['instantConvertWithdrawal'][0])
    {
        list($response) = $this->instantConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);
        return $response;
    }

    /**
     * Operation instantConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function instantConvertWithdrawalWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['instantConvertWithdrawal'][0])
    {
        $request = $this->instantConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation instantConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instantConvertWithdrawalAsync($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['instantConvertWithdrawal'][0])
    {
        return $this->instantConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation instantConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/instant
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function instantConvertWithdrawalAsyncWithHttpInfo($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['instantConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response';
        $request = $this->instantConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo, $external_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'instantConvertWithdrawal'
     *
     * @param  mixed $currency the currency to be converted (required)
     * @param  mixed $amount the amount in currency to be converted (required)
     * @param  mixed $target_currency the currency into which the conversion will take place (required)
     * @param  mixed $address the address of the crypto wallet to which the funds will be withdrawn (required)
     * @param  mixed $network crypto wallet network (required)
     * @param  mixed|null $memo crypto wallet memo (optional)
     * @param  mixed|null $external_id external id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['instantConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function instantConvertWithdrawalRequest($currency, $amount, $target_currency, $address, $network, $memo = null, $external_id = null, string $contentType = self::contentTypes['instantConvertWithdrawal'][0])
    {

        // verify the required parameter 'currency' is set
        if ($currency === null || (is_array($currency) && count($currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $currency when calling instantConvertWithdrawal'
            );
        }

        // verify the required parameter 'amount' is set
        if ($amount === null || (is_array($amount) && count($amount) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $amount when calling instantConvertWithdrawal'
            );
        }

        // verify the required parameter 'target_currency' is set
        if ($target_currency === null || (is_array($target_currency) && count($target_currency) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $target_currency when calling instantConvertWithdrawal'
            );
        }

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling instantConvertWithdrawal'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling instantConvertWithdrawal'
            );
        }




        $resourcePath = '/private-api/convert-withdrawal/instant';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $currency,
            'currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_currency,
            'target_currency', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $network,
            'network', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $memo,
            'memo', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $external_id,
            'external_id', // param base name
            'mixed', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation payAcquiring
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['payAcquiring'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetAcquiringCurrencies200Response
     */
    public function payAcquiring($slug, string $contentType = self::contentTypes['payAcquiring'][0])
    {
        list($response) = $this->payAcquiringWithHttpInfo($slug, $contentType);
        return $response;
    }

    /**
     * Operation payAcquiringWithHttpInfo
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['payAcquiring'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetAcquiringCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function payAcquiringWithHttpInfo($slug, string $contentType = self::contentTypes['payAcquiring'][0])
    {
        $request = $this->payAcquiringRequest($slug, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetAcquiringCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation payAcquiringAsync
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['payAcquiring'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function payAcquiringAsync($slug, string $contentType = self::contentTypes['payAcquiring'][0])
    {
        return $this->payAcquiringAsyncWithHttpInfo($slug, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation payAcquiringAsyncWithHttpInfo
     *
     * POST /acquiring/{slug}/pay
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['payAcquiring'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function payAcquiringAsyncWithHttpInfo($slug, string $contentType = self::contentTypes['payAcquiring'][0])
    {
        $returnType = '\PayPlayClient\Model\GetAcquiringCurrencies200Response';
        $request = $this->payAcquiringRequest($slug, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'payAcquiring'
     *
     * @param  string $slug unique instance name defined for payment page. can be found on each payment page settings page in CRM. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['payAcquiring'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function payAcquiringRequest($slug, string $contentType = self::contentTypes['payAcquiring'][0])
    {

        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling payAcquiring'
            );
        }


        $resourcePath = '/acquiring/{slug}/pay';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation refreshConvertWithdrawal
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response
     */
    public function refreshConvertWithdrawal($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        list($response) = $this->refreshConvertWithdrawalWithHttpInfo($transaction_id, $contentType);
        return $response;
    }

    /**
     * Operation refreshConvertWithdrawalWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \PayPlayClient\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function refreshConvertWithdrawalWithHttpInfo($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        $request = $this->refreshConvertWithdrawalRequest($transaction_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation refreshConvertWithdrawalAsync
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshConvertWithdrawalAsync($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        return $this->refreshConvertWithdrawalAsyncWithHttpInfo($transaction_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation refreshConvertWithdrawalAsyncWithHttpInfo
     *
     * POST /private-api/convert-withdrawal/{transactionID}/refresh
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function refreshConvertWithdrawalAsyncWithHttpInfo($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {
        $returnType = '\PayPlayClient\Model\GetConvertWithdrawalCurrencies200Response';
        $request = $this->refreshConvertWithdrawalRequest($transaction_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'refreshConvertWithdrawal'
     *
     * @param  string $transaction_id PayPlay transaction id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['refreshConvertWithdrawal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function refreshConvertWithdrawalRequest($transaction_id, string $contentType = self::contentTypes['refreshConvertWithdrawal'][0])
    {

        // verify the required parameter 'transaction_id' is set
        if ($transaction_id === null || (is_array($transaction_id) && count($transaction_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transaction_id when calling refreshConvertWithdrawal'
            );
        }


        $resourcePath = '/private-api/convert-withdrawal/{transactionID}/refresh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($transaction_id !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionID' . '}',
                ObjectSerializer::toPathValue($transaction_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
